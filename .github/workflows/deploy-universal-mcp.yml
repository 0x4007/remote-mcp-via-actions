name: Deploy Universal MCP Gateway
#
# Universal MCP Gateway with Zero-Configuration Auto-Discovery
#
# This workflow automatically discovers and sets up any MCP servers through
# the Universal Setup Script Convention. No server-specific configuration
# required - just add servers as git submodules.

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-universal-mcp-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Initialize submodules
        run: |
          echo "Initializing git submodules..."
          git submodule sync --recursive
          git submodule update --init --recursive --force
          echo "âœ… Submodules initialized"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Python (for Python MCP servers)
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Bridge Dependencies
        working-directory: src/bridge
        run: |
          npm install

      - name: Start Custom MCP Server
        working-directory: src/bridge
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          PORT: 8080
        run: |
          echo "ðŸš€ Starting Custom MCP Server..."

          # Ensure API key is available
          if [[ -z "${OPENROUTER_API_KEY}" ]]; then
            echo "âŒ No OPENROUTER_API_KEY found"
            exit 1
          fi

          # Start bridge server
          nohup node server.js > bridge.log 2>&1 &
          BRIDGE_PID=$!
          echo "Custom MCP Server started with PID: $BRIDGE_PID"

          # Wait for server to start
          for i in {1..30}; do
            if curl -s http://localhost:8080/health > /dev/null 2>&1; then
              echo "âœ… Custom MCP Server started successfully"
              echo "Server info:"
              curl -s http://localhost:8080/health | jq
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done

          if ! curl -s http://localhost:8080/health > /dev/null 2>&1; then
            echo "âŒ Failed to start Custom MCP Server"
            echo "Server logs:"
            cat bridge.log
            exit 1
          fi

      - name: Install and Start Cloudflare Tunnel
        run: |
          echo "Installing cloudflared..."
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          
          echo "Starting Cloudflare tunnel..."
          mkdir -p logs
          nohup cloudflared tunnel --no-autoupdate --url http://localhost:8080 > logs/cloudflared.log 2>&1 &

          # Wait for tunnel URL
          for i in {1..30}; do
            if grep -q "https://.*\.trycloudflare\.com" logs/cloudflared.log; then
              TUNNEL_URL=$(grep -o 'https://[^[:space:]]*\.trycloudflare\.com' logs/cloudflared.log | head -1)
              echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV
              echo "âœ… Tunnel established: $TUNNEL_URL"
              break
            fi
            echo "Waiting for tunnel... ($i/30)"
            sleep 2
          done

          if [[ -z "$TUNNEL_URL" ]]; then
            echo "âŒ Failed to establish tunnel"
            cat logs/cloudflared.log
            exit 1
          fi

      - name: Test Public Endpoint
        run: |
          echo "Testing public endpoint..."
          sleep 5

          HEALTH_RESPONSE=$(curl -s --max-time 10 $TUNNEL_URL/health 2>&1 || echo "failed")

          if echo "$HEALTH_RESPONSE" | jq -e . > /dev/null 2>&1; then
            echo "âœ… Public endpoint working!"
            echo "$HEALTH_RESPONSE" | jq .
            echo "ENDPOINT_WORKING=true" >> $GITHUB_ENV
          else
            echo "âŒ Public endpoint failed"
            echo "Response: $HEALTH_RESPONSE"
            echo "ENDPOINT_WORKING=false" >> $GITHUB_ENV
          fi

      - name: Display Connection Info
        if: env.ENDPOINT_WORKING == 'true'
        run: |
          echo "=================================="
          echo "ðŸš€ Universal MCP Gateway Online!"
          echo "=================================="
          echo ""
          echo "Primary URL: $TUNNEL_URL"
          echo "Health Check: $TUNNEL_URL/health"
          echo "MCP Protocol: $TUNNEL_URL/"
          echo "MCP Inspector: $TUNNEL_URL/mcp"
          echo ""
          echo "Claude Code setup:"
          echo "claude mcp add --transport http universal-demo $TUNNEL_URL/"
          echo ""
          echo "Individual servers available at:"
          SERVERS=$(curl -s $TUNNEL_URL/health | jq -r '.serverList[]?.name // empty' 2>/dev/null || echo "")
          if [[ -n "$SERVERS" ]]; then
            echo "$SERVERS" | while read server; do
              [[ -n "$server" ]] && echo "  - $TUNNEL_URL/mcp/$server"
            done
          fi

      - name: Update Cloudflare Worker KV
        if: env.ENDPOINT_WORKING == 'true'
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "Updating Cloudflare Worker KV with tunnel URL..."
          KV_NAMESPACE_ID="7e1605c08a3c407c9f8a331f25b5c117"
          KV_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/storage/kv/namespaces/$KV_NAMESPACE_ID/values/url" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: text/plain" \
            --data "$TUNNEL_URL")
          echo "âœ… Worker KV updated with tunnel URL"
          echo "mcp.pavlovcik.com will now proxy to $TUNNEL_URL"
          echo ""
          echo "Claude Code MCP configuration:"
          echo "claude mcp add --transport http universal-demo https://mcp.pavlovcik.com/"

      - name: KV Update Skipped
        if: env.ENDPOINT_WORKING == 'false'
        run: |
          echo "âš ï¸  KV update was skipped due to failed endpoint test"
          echo "âš ï¸  The existing mcp.pavlovcik.com service should continue working"
          echo "âš ï¸  This prevents breaking the service when tunnel registration fails"

      - name: Keep Server Running  
        if: env.ENDPOINT_WORKING == 'true'
        run: |
          echo "ðŸ”„ Custom MCP Server running"
          echo "â±ï¸  Server has a 1-hour inactivity timeout"
          echo "ðŸ” Health check requests do not reset the timeout timer"
          echo ""

          # Monitor server process and health
          BRIDGE_PID=$(pgrep -f "node server.js")
          while kill -0 $BRIDGE_PID 2>/dev/null; do
            HEALTH_RESPONSE=$(curl -s http://localhost:8080/health 2>/dev/null || echo "{}")
            if echo "$HEALTH_RESPONSE" | jq -e . > /dev/null 2>&1; then
              UPTIME=$(echo "$HEALTH_RESPONSE" | jq -r '.uptime // 0')
              SESSIONS=$(echo "$HEALTH_RESPONSE" | jq -r '.activeSessions // 0')
              TIMEOUT_SECS=$(echo "$HEALTH_RESPONSE" | jq -r '.timeUntilTimeout // 900')
              TIMEOUT_MINS=$((TIMEOUT_SECS / 60))
              echo "[$(date)] Server running - Uptime: ${UPTIME}s, Active sessions: ${SESSIONS}, Timeout in: ${TIMEOUT_MINS} minutes"
            fi
            sleep 60
          done
          echo "Server has shut down"

      - name: Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gateway-logs
          path: |
            src/bridge/bridge.log
            logs/cloudflared.log