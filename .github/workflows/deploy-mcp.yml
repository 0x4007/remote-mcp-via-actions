name: Deploy MCP

on:
  workflow_dispatch:

jobs:
  host-mcp:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # Max 6 hours (360 minutes)
    concurrency:
      group: deploy-mcp-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Cancel ALL existing Deploy MCP runs
        timeout-minutes: 3
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "🔥 CANCELLING ALL EXISTING Deploy MCP WORKFLOWS"
          echo "=============================================="

          # Get the current run ID to avoid canceling ourselves
          CURRENT_RUN_ID=${{ github.run_id }}
          echo "Current run ID: $CURRENT_RUN_ID"

          # Get ALL running Deploy MCP workflows across the entire repository
          echo "Finding ALL Deploy MCP workflows in any state..."

          ALL_DEPLOY_RUNS=$(gh api repos/${{ github.repository }}/actions/runs \
            --paginate \
            --jq '.workflow_runs[] | select(.name == "Deploy MCP" and (.status == "in_progress" or .status == "queued" or .status == "requested" or .status == "waiting")) | select(.id != '$CURRENT_RUN_ID') | .id')

          echo "Found runs to cancel: $(echo "$ALL_DEPLOY_RUNS" | wc -l | tr -d ' ')"

          if [ -z "$ALL_DEPLOY_RUNS" ]; then
            echo "✅ No other Deploy MCP runs found."
          else
            echo "🎯 Target runs for cancellation:"
            echo "$ALL_DEPLOY_RUNS"
            echo ""

            # Force cancel ALL Deploy MCP runs
            echo "🔥 FORCE CANCELLING ALL Deploy MCP RUNS..."
            echo "$ALL_DEPLOY_RUNS" | while IFS= read -r RUN_ID; do
              if [ ! -z "$RUN_ID" ] && [ "$RUN_ID" != "$CURRENT_RUN_ID" ]; then
                echo "🔥 Cancelling Deploy MCP run: $RUN_ID"

                # Try multiple approaches to ensure cancellation
                timeout 15 gh run cancel "$RUN_ID" --repo ${{ github.repository }} 2>/dev/null || \
                timeout 15 gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/cancel -X POST 2>/dev/null || \
                echo "⚠️ Failed to cancel run $RUN_ID"

                # Don't wait - be aggressive
                sleep 1
              fi
            done

            echo ""
            echo "🔥 All Deploy MCP cancellation requests sent!"
            echo "⏳ Waiting 15 seconds for cancellations to process..."
            sleep 15
          fi

          # Final status check
          echo ""
          echo "📊 Final Deploy MCP workflow status:"
          gh api repos/${{ github.repository }}/actions/runs \
            --jq '.workflow_runs[] | select(.name == "Deploy MCP") | "\(.id): \(.status) - \(.created_at)"' | head -10 || echo "Failed to get status"

          echo ""
          echo "✅ Cancellation phase complete. This deployment will now proceed as the ONLY active Deploy MCP workflow."

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Initialize submodules
        run: |
          echo "Initializing git submodules..."
          git submodule sync --recursive
          git submodule update --init --recursive --force

          echo ""
          echo "Verifying Zen server submodule:"
          if [ -f "mcp-servers/zen-mcp-server/server.py" ]; then
            echo "✅ Zen server submodule initialized successfully"
            cd mcp-servers/zen-mcp-server
            echo "Zen server commit: $(git rev-parse HEAD)"
            echo "Zen server branch: $(git branch --show-current || echo 'detached HEAD')"
            ls -la | head -15
            cd ../..
          else
            echo "❌ Failed to initialize Zen server submodule"
            echo "Checking submodule status:"
            git submodule status
            ls -la mcp-servers/
          fi

          echo ""
          echo "All MCP servers:"
          ls -la mcp-servers/

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install MCP Server dependencies
        working-directory: src/bridge
        run: |
          npm install

      - name: Install Zen server dependencies
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          if [ -f "mcp-servers/zen-mcp-server/requirements.txt" ]; then
            echo "Installing Zen server Python dependencies..."
            cd mcp-servers/zen-mcp-server
            pip install -r requirements.txt
            echo "✅ Zen server dependencies installed"

            # Verify Python can import the required modules
            echo ""
            echo "Verifying Python modules:"
            python -c "import asyncio; import json; import sys; print('✅ Core modules available')"

            # Test environment variables
            echo ""
            echo "Testing environment:"
            python -c "import os; print(f'OPENROUTER_API_KEY: {\"SET\" if os.getenv(\"OPENROUTER_API_KEY\") else \"NOT SET\"}')"

            # Test if server.py can start
            echo ""
            echo "Testing server.py startup:"
            timeout 2 python server.py 2>&1 | head -20 || echo "Server test completed"

            cd ../..
          else
            echo "⚠️ Zen server requirements.txt not found - submodules may not be checked out"
            ls -la mcp-servers/
          fi

      - name: Create required directories
        run: |
          mkdir -p logs tmp

      - name: Start Custom MCP Server
        working-directory: src/bridge
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          OPENROUTER_TOKEN: ${{ secrets.OPENROUTER_TOKEN }}
        run: |
          # Export environment variables
          export GITHUB_SHA=${{ github.sha }}
          export DEPLOYMENT_VERSION="${{ github.sha }}"
          export DEPLOYMENT_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # Ensure OPENROUTER_API_KEY is available - try both secrets
          echo "DEBUG: Raw OPENROUTER_API_KEY value: '${OPENROUTER_API_KEY}'"
          echo "DEBUG: OPENROUTER_API_KEY length: ${#OPENROUTER_API_KEY}"
          echo "DEBUG: Raw OPENROUTER_TOKEN value: '${OPENROUTER_TOKEN}'"
          echo "DEBUG: OPENROUTER_TOKEN length: ${#OPENROUTER_TOKEN}"

          # Use OPENROUTER_TOKEN if OPENROUTER_API_KEY is empty
          if [ -z "${OPENROUTER_API_KEY}" ] && [ -n "${OPENROUTER_TOKEN}" ]; then
            echo "🔄 OPENROUTER_API_KEY is empty, using OPENROUTER_TOKEN instead"
            export OPENROUTER_API_KEY="${OPENROUTER_TOKEN}"
            echo "✅ Using OPENROUTER_TOKEN as API key (length: ${#OPENROUTER_TOKEN})"
            echo "✅ First 10 chars: ${OPENROUTER_TOKEN:0:10}..."
          elif [ -n "${OPENROUTER_API_KEY}" ]; then
            echo "✅ OPENROUTER_API_KEY is set (length: ${#OPENROUTER_API_KEY})"
            echo "✅ First 10 chars: ${OPENROUTER_API_KEY:0:10}..."
            export OPENROUTER_API_KEY="${OPENROUTER_API_KEY}"
          else
            echo "❌ ERROR: Both OPENROUTER_API_KEY and OPENROUTER_TOKEN are empty!"
            echo "Please ensure at least one is added to GitHub Secrets with a valid value"
            echo "❌ DEPLOYMENT WILL FAIL - Zen server requires API key"
          fi

          # Debug: Check what servers are available
          echo "Checking available MCP servers:"
          ls -la ../../mcp-servers/
          echo ""

          # Start the custom MCP server
          echo "Starting Custom MCP Server..."
          echo "Deployment version: ${GITHUB_SHA:0:8}"
          echo "OPENROUTER_API_KEY is ${OPENROUTER_API_KEY:+set}${OPENROUTER_API_KEY:-not set}"
          nohup env OPENROUTER_API_KEY="${OPENROUTER_API_KEY}" node server.js > bridge.log 2>&1 &
          BRIDGE_PID=$!
          echo "Custom MCP Server started with PID: $BRIDGE_PID"

          # Wait for server to start
          echo "Waiting for server to start..."
          for i in {1..30}; do
            if curl -s http://localhost:8081/health > /dev/null 2>&1; then
              echo "✅ Custom MCP Server started successfully"

              # Display server info
              echo "Server info:"
              curl -s http://localhost:8081/health | jq
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done

          # Verify server is running
          if ! curl -s http://localhost:8081/health > /dev/null 2>&1; then
            echo "❌ Failed to start Custom MCP Server"
            echo "Server logs:"
            cat bridge.log
            exit 1
          fi

          # Show server startup logs
          echo ""
          echo "Server startup logs (first 100 lines):"
          head -100 bridge.log
          echo ""
          echo "Checking for Zen server initialization:"
          grep -i "zen" bridge.log || echo "No Zen server logs found"
          echo ""
          echo "Checking for Python errors:"
          grep -i "python\|error\|exception\|failed" bridge.log | head -20 || echo "No Python errors found"
          echo ""
          echo "Checking discovered servers:"
          grep -i "examining server\|valid MCP server\|skipping" bridge.log || echo "No server discovery logs found"

      - name: Set up Cloudflare Tunnel
        uses: AnimMouse/setup-cloudflared@v1

      - name: Start Cloudflare Quick Tunnel
        run: |
          echo "Starting Cloudflare quick tunnel..."
          nohup cloudflared tunnel --no-autoupdate --url http://localhost:8081 > logs/cloudflared.log 2>&1 &
          TUNNEL_PID=$!
          echo "Cloudflare tunnel starting with PID: $TUNNEL_PID"

          # Wait for tunnel URL
          echo "Waiting for tunnel URL..."
          for i in {1..30}; do
            if grep -q "https://.*\.trycloudflare\.com" logs/cloudflared.log; then
              echo "✅ Tunnel URL found!"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done

          # Extract the tunnel URL
          TUNNEL_URL=$(grep -o 'https://[^[:space:]]*\.trycloudflare\.com' logs/cloudflared.log | head -1)

          if [ -z "$TUNNEL_URL" ]; then
            echo "❌ Failed to get tunnel URL"
            cat logs/cloudflared.log
            exit 1
          fi

          echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV
          echo "✅ Tunnel established at: $TUNNEL_URL"

          # Save to file
          echo "$TUNNEL_URL" > tmp/tunnel_url.txt

      - name: Display endpoint info
        run: |
          echo "==================================="
          echo "Custom MCP Server is now accessible at:"
          echo "$TUNNEL_URL"
          echo ""
          echo "Custom domain will be available at:"
          echo "https://mcp.pavlovcik.com"
          echo "(DNS propagation may take a few minutes)"
          echo ""
          echo "Deployment version: ${{ github.sha }}"
          echo "==================================="
          echo ""
          echo "Available endpoints:"
          echo "  Health: $TUNNEL_URL/health"
          echo "  MCP Protocol: $TUNNEL_URL/"
          echo ""
          echo "Via custom domain (after DNS propagates):"
          echo "  Health: https://mcp.pavlovcik.com/health"
          echo "  MCP Protocol: https://mcp.pavlovcik.com/"
          echo ""
          echo "Available tools: 21+ tools from main, calculator, and Zen servers"
          echo ""

          # Save endpoints to file
          cat > tmp/endpoints.txt << EOF
          Custom MCP Server Endpoints:
          Base URL: $TUNNEL_URL
          Health: $TUNNEL_URL/health
          MCP Protocol: $TUNNEL_URL/
          Tools: calculate_sum, echo
          EOF

          # Test the public endpoint
          echo "Testing public endpoint..."
          sleep 5

          HEALTH_RESPONSE=$(curl -s --max-time 10 $TUNNEL_URL/health 2>&1 || true)

          if echo "$HEALTH_RESPONSE" | jq -e . > /dev/null 2>&1; then
            echo "✅ Public endpoint is working!"
            echo "$HEALTH_RESPONSE" | jq
            echo "ENDPOINT_TEST_PASSED=true" >> $GITHUB_ENV
          else
            echo "❌ Public endpoint test failed!"
            echo "Response:"
            echo "$HEALTH_RESPONSE"
            echo "ENDPOINT_TEST_PASSED=false" >> $GITHUB_ENV
            echo "⚠️  Will not update KV store with broken tunnel URL"
            echo "⚠️  Continuing deployment but skipping KV update to prevent breaking existing service"
          fi

      - name: Upload tunnel info
        uses: actions/upload-artifact@v4
        with:
          name: tunnel-info
          path: |
            tmp/tunnel_url.txt
            tmp/endpoints.txt
            logs/cloudflared.log

      - name: Update tunnel status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a simple JSON file with the current tunnel URL
          mkdir -p docs
          cat > docs/tunnel-status.json << EOF
          {
            "url": "$TUNNEL_URL",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "active",
            "endpoints": {
              "health": "$TUNNEL_URL/health",
              "mcp": "$TUNNEL_URL/"
            },
            "tools": ["21+ tools from multiple servers"],
            "servers": ["main", "example-calculator", "zen-mcp-server"],
            "protocol": "MCP Streamable HTTP 2025-06-18"
          }
          EOF

          echo "Tunnel status saved"

          # Commit and push to GitHub Pages
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add docs/tunnel-status.json
          git commit -m "Update tunnel status" || echo "No changes to commit"
          git push || echo "Push failed"

      - name: Update Cloudflare Worker KV
        if: env.ENDPOINT_TEST_PASSED == 'true'
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "Updating Cloudflare Worker KV with tunnel URL..."

          # KV namespace ID for MCP_TUNNEL_URL
          KV_NAMESPACE_ID="7e1605c08a3c407c9f8a331f25b5c117"

          # Update KV with tunnel URL
          KV_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/storage/kv/namespaces/$KV_NAMESPACE_ID/values/url" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: text/plain" \
            --data "$TUNNEL_URL")

          echo "✅ Worker KV updated with tunnel URL"
          echo "mcp.pavlovcik.com will now proxy to $TUNNEL_URL"
          echo ""
          echo "Claude Code MCP configuration:"
          echo "claude mcp add --transport http custom-demo https://mcp.pavlovcik.com/"

      - name: KV Update Skipped
        if: env.ENDPOINT_TEST_PASSED == 'false'
        run: |
          echo "⚠️  KV update was skipped due to failed endpoint test"
          echo "⚠️  The existing mcp.pavlovcik.com service should continue working"
          echo "⚠️  This prevents breaking the service when tunnel registration fails"

      - name: Keep server running
        # Always keep running, even if endpoint test fails (for debugging)
        run: |
          echo "Custom MCP Server running at: $TUNNEL_URL"
          echo "Available tools: 21+ tools from main, calculator, and Zen servers"
          echo "Protocol: MCP Streamable HTTP 2025-06-18"
          echo ""
          echo "⏱️  Server has a 1-hour inactivity timeout"
          echo "The server will automatically shut down if no MCP requests are received for 1 hour."
          echo "Health check requests do not reset the timeout timer."
          echo ""
          echo "Server will keep running until either:"
          echo "  - 1 hour of inactivity (no MCP requests)"
          echo "  - GitHub Actions timeout (6 hours max)"
          echo ""

          # Monitor the server process
          BRIDGE_PID=$(pgrep -f "node server.js")

          # Keep checking if the process is alive
          while kill -0 $BRIDGE_PID 2>/dev/null; do
            # Check health endpoint
            HEALTH_RESPONSE=$(curl -s http://localhost:8081/health 2>/dev/null || echo "{}")
            if echo "$HEALTH_RESPONSE" | jq -e . > /dev/null 2>&1; then
              UPTIME=$(echo "$HEALTH_RESPONSE" | jq -r '.uptime // 0')
              SESSIONS=$(echo "$HEALTH_RESPONSE" | jq -r '.activeSessions // 0')
              TIMEOUT_SECS=$(echo "$HEALTH_RESPONSE" | jq -r '.timeUntilTimeout // 900')
              TIMEOUT_MINS=$((TIMEOUT_SECS / 60))
              echo "[$(date)] Server running - Uptime: ${UPTIME}s, Active sessions: ${SESSIONS}, Timeout in: ${TIMEOUT_MINS} minutes"
            fi

            sleep 60  # Check every minute
          done

          echo "Server has shut down"

      - name: Deployment Failed - Cleanup
        if: env.ENDPOINT_TEST_PASSED == 'false'
        run: |
          echo "❌ Deployment failed due to tunnel connectivity issues"
          echo "❌ Existing service at mcp.pavlovcik.com should continue working"
          echo "❌ This deployment will be terminated to avoid resource waste"
          echo ""
          echo "To debug:"
          echo "1. Check if cloudflared tunnel process died early"
          echo "2. Check tunnel registration logs"
          echo "3. Verify local server is responding on port 8081"