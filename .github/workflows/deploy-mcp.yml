name: Deploy MCP

on:
  workflow_dispatch:

jobs:
  host-mcp:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    concurrency:
      group: deploy-mcp-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Cancel ALL existing Deploy MCP runs
        timeout-minutes: 3
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üî• CANCELLING ALL EXISTING Deploy MCP WORKFLOWS"
          echo "=============================================="
          CURRENT_RUN_ID=${{ github.run_id }}
          echo "Current run ID: $CURRENT_RUN_ID"
          echo "Finding ALL Deploy MCP workflows in any state..."
          ALL_DEPLOY_RUNS=$(gh api repos/${{ github.repository }}/actions/runs \
            --paginate \
            --jq '.workflow_runs[] | select(.name == "Deploy MCP" and (.status == "in_progress" or .status == "queued" or .status == "requested" or .status == "waiting")) | select(.id != '$CURRENT_RUN_ID') | .id')
          echo "Found runs to cancel: $(echo "$ALL_DEPLOY_RUNS" | wc -l | tr -d ' ')"
          if [ -z "$ALL_DEPLOY_RUNS" ]; then
            echo "‚úÖ No other Deploy MCP runs found."
          else
            echo "üéØ Target runs for cancellation:"
            echo "$ALL_DEPLOY_RUNS"
            echo ""
            echo "üî• FORCE CANCELLING ALL Deploy MCP RUNS..."
            echo "$ALL_DEPLOY_RUNS" | while IFS= read -r RUN_ID; do
              if [ ! -z "$RUN_ID" ] && [ "$RUN_ID" != "$CURRENT_RUN_ID" ]; then
                echo "üî• Cancelling Deploy MCP run: $RUN_ID"
                timeout 15 gh run cancel "$RUN_ID" --repo ${{ github.repository }} 2>/dev/null || \
                timeout 15 gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/cancel -X POST 2>/dev/null || \
                echo "‚ö†Ô∏è Failed to cancel run $RUN_ID"
                sleep 1
              fi
            done
            echo ""
            echo "üî• All Deploy MCP cancellation requests sent!"
            echo "‚è≥ Waiting 15 seconds for cancellations to process..."
            sleep 15
          fi
          echo ""
          echo "üìä Final Deploy MCP workflow status:"
          gh api repos/${{ github.repository }}/actions/runs \
            --jq '.workflow_runs[] | select(.name == "Deploy MCP") | "\(.id): \(.status) - \(.created_at)"' | head -10 || echo "Failed to get status"
          echo ""
          echo "‚úÖ Cancellation phase complete. This deployment will now proceed as the ONLY active Deploy MCP workflow."

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Initialize submodules
        run: |
          echo "Initializing git submodules..."
          git submodule sync --recursive
          git submodule update --init --recursive --force
          echo ""
          echo "Verifying Zen server submodule:"
          if [ -f "mcp-servers/zen-mcp-server/server.py" ]; then
            echo "‚úÖ Zen server submodule initialized successfully"
            cd mcp-servers/zen-mcp-server
            echo "Zen server commit: $(git rev-parse HEAD)"
            echo "Zen server branch: $(git branch --show-current || echo 'detached HEAD')"
            ls -la | head -15
            cd ../..
          else
            echo "‚ùå Failed to initialize Zen server submodule"
            echo "Checking submodule status:"
            git submodule status
            ls -la mcp-servers/
          fi
          echo ""
          echo "All MCP servers:"
          ls -la mcp-servers/

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install MCP Server dependencies
        working-directory: src/bridge
        run: |
          npm install

      - name: Install Zen server dependencies
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          if [ -f "mcp-servers/zen-mcp-server/requirements.txt" ]; then
            echo "Installing Zen server Python dependencies..."
            cd mcp-servers/zen-mcp-server
            pip install -r requirements.txt
            echo "‚úÖ Zen server dependencies installed"
            echo ""
            echo "Verifying Python modules:"
            python -c "import asyncio; import json; import sys; print('‚úÖ Core modules available')"
            echo ""
            echo "Testing environment:"
            python -c "import os; print(f'OPENROUTER_API_KEY: {\"SET\" if os.getenv(\"OPENROUTER_API_KEY\") else \"NOT SET\"}')"
            echo ""
            echo "Applying Grok alias debug patch..."
            export CUSTOM_MODELS_CONFIG_PATH="${{ github.workspace }}/config/custom_models_override.json"
            export GROK_ALIASES_ENABLED="true"
            export GROK_ALIASES="grok,grok-4,grok4,grok-3,grok3,grok-3-fast,grok3-fast,grokfast,grok-fast"
            export PYTHONPATH="${{ github.workspace }}/config:$PYTHONPATH"
            cp "${{ github.workspace }}/config/debug_alias_patch.py" ./
            cp "${{ github.workspace }}/config/zen_server_patch.py" ./
            cp "${{ github.workspace }}/config/direct_alias_injection.py" ./
            echo "Testing debug patch..."
            python -c "import sys; sys.path.insert(0, '.'); import debug_alias_patch; print('‚úÖ Debug patch applied successfully')"
            echo ""
            echo "=== PRE-DEPLOYMENT CONFIG VERIFICATION ==="
            echo "Verifying custom models config loading..."
            python ${{ github.workspace }}/scripts/ci/verify-config.py
            echo ""
            echo "Testing server.py startup:"
            timeout 2 python server.py 2>&1 | head -20 || echo "Server test completed"
            cd ../..
          else
            echo "‚ö†Ô∏è Zen server requirements.txt not found - submodules may not be checked out"
            ls -la mcp-servers/
          fi

      - name: Create required directories
        run: |
          mkdir -p logs tmp

      - name: Start Custom MCP Server
        working-directory: src/bridge
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          OPENROUTER_TOKEN: ${{ secrets.OPENROUTER_TOKEN }}
          CUSTOM_MODELS_CONFIG_PATH: ${{ github.workspace }}/config/custom_models_override.json
          GROK_ALIASES_ENABLED: "true"
          GROK_ALIASES: "grok,grok-4,grok4,grok-3,grok3,grok-3-fast,grok3-fast,grokfast,grok-fast"
          PYTHONPATH: ${{ github.workspace }}/config:$PYTHONPATH
        run: |
          export GITHUB_SHA=${{ github.sha }}
          export DEPLOYMENT_VERSION="${{ github.sha }}"
          export DEPLOYMENT_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          export CUSTOM_MODELS_CONFIG_PATH="${{ github.workspace }}/config/custom_models_override.json"
          export GROK_ALIASES_ENABLED="true"
          export PYTHONPATH="${{ github.workspace }}/config:$PYTHONPATH"
          echo "DEBUG: Raw OPENROUTER_API_KEY value: '${OPENROUTER_API_KEY}'"
          echo "DEBUG: OPENROUTER_API_KEY length: ${#OPENROUTER_API_KEY}"
          echo "DEBUG: Raw OPENROUTER_TOKEN value: '${OPENROUTER_TOKEN}'"
          echo "DEBUG: OPENROUTER_TOKEN length: ${#OPENROUTER_TOKEN}"
          if [ -z "${OPENROUTER_API_KEY}" ] && [ -n "${OPENROUTER_TOKEN}" ]; then
            echo "üîÑ OPENROUTER_API_KEY is empty, using OPENROUTER_TOKEN instead"
            export OPENROUTER_API_KEY="${OPENROUTER_TOKEN}"
            echo "‚úÖ Using OPENROUTER_TOKEN as API key (length: ${#OPENROUTER_TOKEN})"
            echo "‚úÖ First 10 chars: ${OPENROUTER_TOKEN:0:10}..."
          elif [ -n "${OPENROUTER_API_KEY}" ]; then
            echo "‚úÖ OPENROUTER_API_KEY is set (length: ${#OPENROUTER_API_KEY})"
            echo "‚úÖ First 10 chars: ${OPENROUTER_API_KEY:0:10}..."
            export OPENROUTER_API_KEY="${OPENROUTER_API_KEY}"
          else
            echo "‚ùå ERROR: Both OPENROUTER_API_KEY and OPENROUTER_TOKEN are empty!"
            echo "Please ensure at least one is added to GitHub Secrets with a valid value"
            echo "‚ùå DEPLOYMENT WILL FAIL - Zen server requires API key"
          fi
          echo "Checking available MCP servers:"
          ls -la ../../mcp-servers/
          echo ""
          echo "Copying debug and alias injection patches to Zen server..."
          cp "${CUSTOM_MODELS_CONFIG_PATH%/*}/debug_alias_patch.py" ../../mcp-servers/zen-mcp-server/ || echo "Debug alias patch copy failed"
          cp "${CUSTOM_MODELS_CONFIG_PATH%/*}/zen_server_patch.py" ../../mcp-servers/zen-mcp-server/ || echo "Zen server patch copy failed"
          cp "${CUSTOM_MODELS_CONFIG_PATH%/*}/direct_alias_injection.py" ../../mcp-servers/zen-mcp-server/ || echo "Direct alias injection copy failed"
          echo "Creating patched server.py..."
          cd ../../mcp-servers/zen-mcp-server/
          cp server.py server_original.py
          cp ${{ github.workspace }}/scripts/ci/server-patched.py ./server_patched.py
          if [ "$GROK_ALIASES_ENABLED" = "true" ]; then
            echo "Replacing server.py with patched version for debugging..."
            mv server.py server_backup.py
            mv server_patched.py server.py
            echo "‚úÖ Patched server.py is now active"
          fi
          cd ../../src/bridge/
          echo "Starting Custom MCP Server with debug patch..."
          echo "Deployment version: ${GITHUB_SHA:0:8}"
          echo "OPENROUTER_API_KEY is ${OPENROUTER_API_KEY:+set}${OPENROUTER_API_KEY:-not set}"
          echo "CUSTOM_MODELS_CONFIG_PATH: ${CUSTOM_MODELS_CONFIG_PATH}"
          echo "GROK_ALIASES_ENABLED: ${GROK_ALIASES_ENABLED}"
          nohup env \
            OPENROUTER_API_KEY="${OPENROUTER_API_KEY}" \
            CUSTOM_MODELS_CONFIG_PATH="${CUSTOM_MODELS_CONFIG_PATH}" \
            GROK_ALIASES_ENABLED="${GROK_ALIASES_ENABLED}" \
            GROK_ALIASES="${GROK_ALIASES}" \
            PYTHONPATH="${PYTHONPATH}" \
            node server.js > bridge.log 2>&1 &
          BRIDGE_PID=$!
          echo "Custom MCP Server started with PID: $BRIDGE_PID"
          echo "Waiting for server to start..."
          for i in {1..30}; do
            if curl -s http://localhost:8081/health > /dev/null 2>&1; then
              echo "‚úÖ Custom MCP Server started successfully"
              echo "Server info:"
              curl -s http://localhost:8081/health | jq
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done
          if ! curl -s http://localhost:8081/health > /dev/null 2>&1; then
            echo "‚ùå Failed to start Custom MCP Server"
            echo "Server logs:"
            cat bridge.log
            exit 1
          fi
          echo ""
          echo "Server startup logs (first 100 lines):"
          head -100 bridge.log
          echo ""
          echo "Checking for Zen server initialization:"
          grep -i "zen" bridge.log || echo "No Zen server logs found"
          echo ""
          echo "Checking for Python errors:"
          grep -i "python\|error\|exception\|failed" bridge.log | head -20 || echo "No Python errors found"
          echo ""
          echo "Checking discovered servers:"
          grep -i "examining server\|valid MCP server\|skipping" bridge.log || echo "No server discovery logs found"

      - name: Install cloudflared
        run: |
          curl -L --output /tmp/cloudflared https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
          chmod +x /tmp/cloudflared
          sudo mv /tmp/cloudflared /usr/local/bin/

      - name: Start Cloudflare Quick Tunnel
        env:
          TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          echo "Starting Cloudflare quick tunnel..."
          nohup cloudflared tunnel --no-autoupdate run --token $TUNNEL_TOKEN > logs/cloudflared.log 2>&1 &
          TUNNEL_PID=$!
          echo "Cloudflare tunnel starting with PID: $TUNNEL_PID"
          echo "Waiting for tunnel URL..."
          for i in {1..30}; do
            if grep -q "https://.*\.trycloudflare\.com" logs/cloudflared.log; then
              echo "‚úÖ Tunnel URL found!"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done
          TUNNEL_URL=$(grep -o 'https://[^[:space:]]*\.trycloudflare\.com' logs/cloudflared.log | head -1)
          if [ -z "$TUNNEL_URL" ]; then
            echo "‚ùå Failed to get tunnel URL"
            cat logs/cloudflared.log
            exit 1
          fi
          echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV
          echo "‚úÖ Tunnel established at: $TUNNEL_URL"
          echo "$TUNNEL_URL" > tmp/tunnel_url.txt

      - name: Display endpoint info
        run: |
          echo "==================================="
          echo "Custom MCP Server is now accessible at:"
          echo "$TUNNEL_URL"
          echo ""
          echo "Custom domain will be available at:"
          echo "https://mcp.pavlovcik.com"
          echo "(DNS propagation may take a few minutes)"
          echo ""
          echo "Deployment version: ${{ github.sha }}"
          echo "==================================="
          echo ""
          echo "Available endpoints:"
          echo "  Health: $TUNNEL_URL/health"
          echo "  MCP Protocol: $TUNNEL_URL/"
          echo ""
          echo "Via custom domain (after DNS propagates):"
          echo "  Health: https://mcp.pavlovcik.com/health"
          echo "  MCP Protocol: https://mcp.pavlovcik.com/"
          echo ""
          echo "Available tools: 21+ tools from main, calculator, and Zen servers"
          echo ""
          cat > tmp/endpoints.txt << EOF
          Custom MCP Server Endpoints:
          Base URL: $TUNNEL_URL
          Health: $TUNNEL_URL/health
          MCP Protocol: $TUNNEL_URL/
          Tools: calculate_sum, echo
          EOF
          echo "Testing public endpoint..."
          sleep 5
          HEALTH_RESPONSE=$(curl -s --max-time 10 $TUNNEL_URL/health 2>&1 || true)
          if echo "$HEALTH_RESPONSE" | jq -e . > /dev/null 2>&1; then
            echo "‚úÖ Public endpoint is working!"
            echo "$HEALTH_RESPONSE" | jq
            echo "ENDPOINT_TEST_PASSED=true" >> $GITHUB_ENV
          else
            echo "‚ùå Public endpoint test failed!"
            echo "Response:"
            echo "$HEALTH_RESPONSE"
            echo "ENDPOINT_TEST_PASSED=false" >> $GITHUB_ENV
            echo "‚ö†Ô∏è  Will not update KV store with broken tunnel URL"
            echo "‚ö†Ô∏è  Continuing deployment but skipping KV update to prevent breaking existing service"
          fi

      - name: Upload tunnel info
        uses: actions/upload-artifact@v4
        with:
          name: tunnel-info
          path: |
            tmp/tunnel_url.txt
            tmp/endpoints.txt
            logs/cloudflared.log

      - name: Update tunnel status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p docs
          cat > docs/tunnel-status.json << EOF
          {
            "url": "$TUNNEL_URL",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "active",
            "endpoints": {
              "health": "$TUNNEL_URL/health",
              "mcp": "$TUNNEL_URL/"
            },
            "tools": ["21+ tools from multiple servers"],
            "servers": ["main", "example-calculator", "zen-mcp-server"],
            "protocol": "MCP Streamable HTTP 2025-06-18"
          }
          EOF
          echo "Tunnel status saved"
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add docs/tunnel-status.json
          git commit -m "Update tunnel status" || echo "No changes to commit"
          git push || echo "Push failed"

      - name: Update Cloudflare Worker KV
        if: env.ENDPOINT_TEST_PASSED == 'true'
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "Updating Cloudflare Worker KV with tunnel URL..."
          KV_NAMESPACE_ID="7e1605c08a3c407c9f8a331f25b5c117"
          KV_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/storage/kv/namespaces/$KV_NAMESPACE_ID/values/url" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: text/plain" \
            --data "$TUNNEL_URL")
          echo "‚úÖ Worker KV updated with tunnel URL"
          echo "mcp.pavlovcik.com will now proxy to $TUNNEL_URL"
          echo ""
          echo "Claude Code MCP configuration:"
          echo "claude mcp add --transport http custom-demo https://mcp.pavlovcik.com/"

      - name: KV Update Skipped
        if: env.ENDPOINT_TEST_PASSED == 'false'
        run: |
          echo "‚ö†Ô∏è  KV update was skipped due to failed endpoint test"
          echo "‚ö†Ô∏è  The existing mcp.pavlovcik.com service should continue working"
          echo "‚ö†Ô∏è  This prevents breaking the service when tunnel registration fails"

      - name: Keep server running
        run: |
          echo "Custom MCP Server running at: $TUNNEL_URL"
          echo "Available tools: 21+ tools from main, calculator, and Zen servers"
          echo "Protocol: MCP Streamable HTTP 2025-06-18"
          echo ""
          echo "‚è±Ô∏è  Server has a 1-hour inactivity timeout"
          echo "The server will automatically shut down if no MCP requests are received for 1 hour."
          echo "Health check requests do not reset the timeout timer."
          echo ""
          echo "Server will keep running until either:"
          echo "  - 1 hour of inactivity (no MCP requests)"
          echo "  - GitHub Actions timeout (6 hours max)"
          echo ""
          BRIDGE_PID=$(pgrep -f "node server.js")
          while kill -0 $BRIDGE_PID 2>/dev/null; do
            HEALTH_RESPONSE=$(curl -s http://localhost:8081/health 2>/dev/null || echo "{}")
            if echo "$HEALTH_RESPONSE" | jq -e . > /dev/null 2>&1; then
              UPTIME=$(echo "$HEALTH_RESPONSE" | jq -r '.uptime // 0')
              SESSIONS=$(echo "$HEALTH_RESPONSE" | jq -r '.activeSessions // 0')
              TIMEOUT_SECS=$(echo "$HEALTH_RESPONSE" | jq -r '.timeUntilTimeout // 900')
              TIMEOUT_MINS=$((TIMEOUT_SECS / 60))
              echo "[$(date)] Server running - Uptime: ${UPTIME}s, Active sessions: ${SESSIONS}, Timeout in: ${TIMEOUT_MINS} minutes"
            fi
            sleep 60
          done
          echo "Server has shut down"

      - name: Deployment Failed - Cleanup
        if: env.ENDPOINT_TEST_PASSED == 'false'
        run: |
          echo "‚ùå Deployment failed due to tunnel connectivity issues"
          echo "‚ùå Existing service at mcp.pavlovcik.com should continue working"
          echo "‚ùå This deployment will be terminated to avoid resource waste"
          echo ""
          echo "To debug:"
          echo "1. Check if cloudflared tunnel process died early"
          echo "2. Check tunnel registration logs"
          echo "3. Verify local server is responding on port 8081"
